//! ZK Proof verification for Shadow-EVM
//!
//! Handles verification of STARK proofs generated by the prover.

use anyhow::{Context, Result};
use risc0_zkvm::Receipt;
use shadow_evm_core::prelude::*;

// Import the guest image ID
use crate::prover::get_image_id;

/// Verification result
#[derive(Debug)]
pub struct VerificationResult {
    /// Whether the proof is valid
    pub valid: bool,
    /// The commitment extracted from the proof
    pub commitment: ExecutionCommitment,
    /// Error message if verification failed
    pub error: Option<String>,
}

/// Verify a ZK proof receipt
///
/// # Arguments
/// * `receipt` - The receipt (proof) to verify
///
/// # Returns
/// * `Ok(VerificationResult)` - The verification result
/// * `Err(...)` - Error if verification process fails
pub fn verify(receipt: &Receipt) -> Result<VerificationResult> {
    let image_id = get_image_id();

    // Verify the receipt against the image ID
    match receipt.verify(image_id) {
        Ok(_) => {
            // Extract the commitment from the journal
            let commitment: ExecutionCommitment = receipt
                .journal
                .decode()
                .context("Failed to decode commitment from journal")?;

            Ok(VerificationResult {
                valid: true,
                commitment,
                error: None,
            })
        }
        Err(e) => {
            // Verification failed, try to extract commitment anyway for debugging
            let commitment = receipt.journal.decode().unwrap_or_else(|_| {
                ExecutionCommitment::new(Hash::ZERO, Hash::ZERO, Hash::ZERO, Hash::ZERO)
            });

            Ok(VerificationResult {
                valid: false,
                commitment,
                error: Some(format!("Verification failed: {}", e)),
            })
        }
    }
}

/// Verify a proof matches expected commitment
///
/// # Arguments
/// * `receipt` - The receipt to verify
/// * `expected_commitment` - The expected commitment hash
///
/// # Returns
/// * `true` if the proof is valid AND the commitment matches
/// * `false` otherwise
pub fn verify_with_commitment(receipt: &Receipt, expected_commitment: &Hash) -> Result<bool> {
    let result = verify(receipt)?;

    if !result.valid {
        return Ok(false);
    }

    Ok(result.commitment.commitment == *expected_commitment)
}

/// Verify state transition
///
/// Checks that a proof represents a valid state transition from
/// the expected pre-state root to the expected post-state root.
pub fn verify_state_transition(
    receipt: &Receipt,
    expected_pre_root: &Hash,
    expected_post_root: &Hash,
) -> Result<bool> {
    let result = verify(receipt)?;

    if !result.valid {
        return Ok(false);
    }

    let commitment = result.commitment;
    Ok(commitment.pre_state_root == *expected_pre_root
        && commitment.post_state_root == *expected_post_root)
}

/// Export proof for on-chain verification
///
/// Returns the data needed to verify the proof in a Solidity contract.
#[derive(Debug)]
pub struct OnChainProof {
    /// The seal (proof bytes)
    pub seal: Vec<u8>,
    /// The image ID
    pub image_id: [u8; 32],
    /// The journal (public outputs)
    pub journal: Vec<u8>,
}

/// Export receipt for on-chain verification
pub fn export_for_onchain(receipt: &Receipt) -> Result<OnChainProof> {
    let seal = receipt
        .inner
        .groth16()
        .context("Receipt must be Groth16 for on-chain verification")?
        .seal
        .clone();

    Ok(OnChainProof {
        seal,
        image_id: get_image_id(),
        journal: receipt.journal.bytes.clone(),
    })
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_verification_result() {
        let commitment = ExecutionCommitment::new(
            Hash::repeat_byte(0x01),
            Hash::repeat_byte(0x02),
            Hash::repeat_byte(0x03),
            Hash::repeat_byte(0x04),
        );

        let result = VerificationResult {
            valid: true,
            commitment: commitment.clone(),
            error: None,
        };

        assert!(result.valid);
        assert_eq!(result.commitment.commitment, commitment.commitment);
    }
}
