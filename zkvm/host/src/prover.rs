//! ZK Proof generation for Shadow-EVM
//!
//! Handles the creation of STARK proofs using RISC Zero.

use anyhow::{Context, Result};
use risc0_zkvm::{default_prover, ExecutorEnv, ExitCode, ProverOpts, Receipt};
use shadow_evm_core::prelude::*;
use std::time::Instant;

// Include the guest ELF binary at compile time
// This will be generated by the build script
include!(concat!(env!("OUT_DIR"), "/methods.rs"));

/// Proof generation options
#[derive(Debug, Clone)]
pub struct ProveOptions {
    /// Enable dev mode (faster but not cryptographically secure)
    pub dev_mode: bool,
    /// Verbose output
    pub verbose: bool,
}

impl Default for ProveOptions {
    fn default() -> Self {
        Self {
            dev_mode: false,
            verbose: false,
        }
    }
}

impl ProveOptions {
    /// Create options for development (fast proofs)
    pub fn dev() -> Self {
        Self {
            dev_mode: true,
            verbose: true,
        }
    }

    /// Create options for production (secure proofs)
    pub fn production() -> Self {
        Self {
            dev_mode: false,
            verbose: false,
        }
    }
}

/// Result of proof generation
#[derive(Debug)]
pub struct ProofResult {
    /// The cryptographic receipt (proof)
    pub receipt: Receipt,
    /// The execution commitment from the journal
    pub commitment: ExecutionCommitment,
    /// Time taken to generate the proof
    pub proving_time_ms: u128,
    /// Guest execution cycles
    pub cycles: u64,
}

/// Generate a ZK proof for an EVM execution
///
/// # Arguments
/// * `input` - The execution input containing block, tx, and pre-state
/// * `options` - Proof generation options
///
/// # Returns
/// * `Ok(ProofResult)` - The proof and commitment on success
/// * `Err(...)` - Error if proof generation fails
pub fn prove(input: ExecutionInput, options: &ProveOptions) -> Result<ProofResult> {
    if options.verbose {
        println!("Starting proof generation...");
        println!("  Input hash: 0x{}", hex::encode(input.hash().as_slice()));
    }

    let start = Instant::now();

    // Create the executor environment with the input
    let env = ExecutorEnv::builder()
        .write(&input)
        .context("Failed to write input to executor environment")?
        .build()
        .context("Failed to build executor environment")?;

    // Get the prover
    let prover = default_prover();

    // Set prover options
    let prover_opts = if options.dev_mode {
        ProverOpts::fast()
    } else {
        ProverOpts::succinct()
    };

    if options.verbose {
        println!(
            "  Mode: {}",
            if options.dev_mode {
                "dev"
            } else {
                "production"
            }
        );
        println!("  Proving...");
    }

    // Generate the proof
    let prove_info = prover
        .prove_with_opts(env, SHADOW_EVM_GUEST_ELF, &prover_opts)
        .context("Failed to generate proof")?;

    let receipt = prove_info.receipt;
    let proving_time_ms = start.elapsed().as_millis();

    // Extract the commitment from the journal
    let commitment: ExecutionCommitment = receipt
        .journal
        .decode()
        .context("Failed to decode commitment from journal")?;

    // Get cycle count
    let cycles = prove_info.stats.total_cycles;

    if options.verbose {
        println!("Proof generation complete!");
        println!("  Time: {}ms", proving_time_ms);
        println!("  Cycles: {}", cycles);
        println!(
            "  Commitment: 0x{}",
            hex::encode(commitment.commitment.as_slice())
        );
    }

    Ok(ProofResult {
        receipt,
        commitment,
        proving_time_ms,
        cycles,
    })
}

/// Execute without proving (for testing)
///
/// Runs the guest program in the executor without generating a proof.
/// Useful for verifying correct execution before spending time on proving.
pub fn execute_only(input: ExecutionInput) -> Result<ExecutionCommitment> {
    let env = ExecutorEnv::builder().write(&input)?.build()?;

    let prover = default_prover();

    // Use fast mode for execution-only
    let prove_info = prover.prove_with_opts(env, SHADOW_EVM_GUEST_ELF, &ProverOpts::fast())?;

    // Verify execution succeeded
    match prove_info.receipt.exit_code {
        ExitCode::Halted(0) => {}
        _ => anyhow::bail!("Guest execution failed"),
    }

    let commitment: ExecutionCommitment = prove_info.receipt.journal.decode()?;
    Ok(commitment)
}

/// Get the image ID for the guest program
///
/// This is needed for on-chain verification.
pub fn get_image_id() -> [u8; 32] {
    SHADOW_EVM_GUEST_ID
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[ignore] // Requires RISC Zero toolchain installed
    fn test_execute_simple() {
        let sender = Address::repeat_byte(0x01);
        let receiver = Address::repeat_byte(0x02);

        let mut state = InMemoryDB::new();
        state.insert_account(
            sender,
            AccountState::new_with_balance(U256::from(10u128.pow(18))),
        );

        let input = ExecutionInput::new(
            BlockEnv::default(),
            TxInput::transfer(sender, receiver, U256::from(1000u64)),
            state,
        );

        let commitment = execute_only(input).unwrap();
        assert!(!commitment.commitment.is_zero());
    }
}
